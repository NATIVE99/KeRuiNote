#include "stdafx.h"
#include "MyMake.h"


CMyMake::CMyMake()
{
}


CMyMake::~CMyMake()
{
}

bool CMyMake::Make(std::string strSrcPath, std::string strDstPath)
{
	//读pe数据
	AnalyzePE(strSrcPath);

	//压缩PE数据
	CompressSectionsData();

	//4. 生成新PE

	GetDecomcode();
	//4.1 构建节区数据
	 GetDeCodeAndDataSec(); //构造压缩数据节


	//4.2 构建节表
	 GetNewSectionHeaders();

	//4.3 构建PE头
	 GetNewPeHdr();


	//写文件
	WriteNewPeFile(strDstPath);

	return true;
}

bool CMyMake::AnalyzePE(std::string strSrcPath)
{
	/*****************************************************************************/
	//打开文件，创建文件映射
	HANDLE hFle = CreateFileA(strSrcPath.c_str(),
		FILE_GENERIC_READ | FILE_GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (hFle == (HANDLE)-1)
	{
		return false;
	}
	HANDLE hFileMap = CreateFileMapping(
		hFle,    // Current file handle. 
		NULL,                              // Default security. 
		PAGE_READWRITE,                    // Read/write permission. 
		0,                                 // Max. object size. 
		0,                                 // Size of hFile. 
		NULL);            // Name of mapping object. 
	if (hFileMap == NULL)
	{
		return false;
	}

	LPVOID lpMapAddress = MapViewOfFile(
		hFileMap, // Handle to mapping object. 
		FILE_MAP_ALL_ACCESS,               // Read/write permission. 
		0,                                 // Max. object size. 
		0,                                 // Size of hFile. 
		0);                                // Map entire file. 

	if (lpMapAddress == NULL)
	{
		return false;
	}
/*****************************************************************************/
	 m_pDosHdr = (PIMAGE_DOS_HEADER)lpMapAddress;

	 m_pNtHdr = (PIMAGE_NT_HEADERS)(m_pDosHdr->e_lfanew+ (DWORD)lpMapAddress);

	 m_pSecHdrs = (PIMAGE_SECTION_HEADER)(m_pNtHdr->FileHeader.SizeOfOptionalHeader+sizeof(m_pNtHdr->Signature)+sizeof(IMAGE_FILE_HEADER)+ (DWORD)m_pNtHdr);

/*******************************************************************************/


	return true;
}

bool CMyMake::CompressSectionsData()
{
	DWORD nSecOffset = 0;
	DWORD nSecSzie = 0;
	DWORD CompressedBufferSize = 0;
	DWORD CompressedDataSize = 0;

	int nSectionNum = m_pNtHdr->FileHeader.NumberOfSections;
	m_pCompressDatas = new CompressDataInfo[nSectionNum];

	COMPRESSOR_HANDLE Compressor = NULL;
	
	for(int i=0;i<nSectionNum;i++)
	{
		//节在文件中的大小和偏移
	/*	nSecSzie =m_pSecHdrs->SizeOfRawData;
		nSecOffset =m_pSecHdrs->PointerToRawData+(DWORD)m_pDosHdr;*/

		char* pSecData = (char*)m_pDosHdr + m_pSecHdrs[i].PointerToRawData;//节数据
		int  nSizeOfSecData = m_pSecHdrs[i].SizeOfRawData; //节数据的大小
		//  Create an XpressHuff compressor.
		BOOL Success = CreateCompressor(
			COMPRESS_ALGORITHM_XPRESS_HUFF, //  Compression Algorithm
			NULL,                           //  Optional allocation routine
			&Compressor);                   //  Handle

		if (!Success)
		{
			wprintf(L"Cannot create a compressor %d.\n", GetLastError());
			return false;
		}
		//  Query compressed buffer size.
		Success = Compress(
			Compressor,                  //  Compressor Handle
			(PVOID)pSecData,                 //  Input buffer, Uncompressed data
			nSizeOfSecData,               //  Uncompressed data size
			NULL,                        //  Compressed Buffer
			0,                           //  Compressed Buffer size
			&CompressedBufferSize);      //  Compressed Data size

		if (Success)
		{
			//DWORD ErrorCode = GetLastError();
			return false;
		}
		char* pCompressedSection = new char[CompressedBufferSize];

		Success = Compress(
			Compressor,             //  Compressor Handle
			(PVOID)pSecData,                 //  Input buffer, Uncompressed data
			nSizeOfSecData,
			pCompressedSection,       //  Compressed Buffer
			CompressedBufferSize,   //  Compressed Buffer size
			&CompressedDataSize);   //  Compressed Data size

		if (!Success)
		{
			wprintf(L"Cannot compress data: %d\n", GetLastError());
			return false;
		}

		m_pCompressDatas[i].m_pComData = pCompressedSection;
		m_pCompressDatas[i].m_nComSize = CompressedDataSize;
		m_pCompressDatas[i].m_nSrcSize = nSizeOfSecData;
	}

	return true;
	
}

bool CMyMake::GetDecomcode()
{
	unsigned char data[1256] = {
		0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x94, 0x00, 0x00, 0x00, 0xE8, 0x72, 0x02, 0x00, 0x00, 0x89, 0x45,
		0x9C, 0xC6, 0x45, 0xCC, 0x4C, 0xC6, 0x45, 0xCD, 0x6F, 0xC6, 0x45, 0xCE, 0x61, 0xC6, 0x45, 0xCF,
		0x64, 0xC6, 0x45, 0xD0, 0x4C, 0xC6, 0x45, 0xD1, 0x69, 0xC6, 0x45, 0xD2, 0x62, 0xC6, 0x45, 0xD3,
		0x72, 0xC6, 0x45, 0xD4, 0x61, 0xC6, 0x45, 0xD5, 0x72, 0xC6, 0x45, 0xD6, 0x79, 0xC6, 0x45, 0xD7,
		0x41, 0xC6, 0x45, 0xD8, 0x00, 0x8D, 0x55, 0xCC, 0x8B, 0x4D, 0x9C, 0xE8, 0x90, 0x02, 0x00, 0x00,
		0x89, 0x45, 0x98, 0xC6, 0x45, 0xE8, 0x43, 0xC6, 0x45, 0xE9, 0x61, 0xC6, 0x45, 0xEA, 0x62, 0xC6,
		0x45, 0xEB, 0x69, 0xC6, 0x45, 0xEC, 0x6E, 0xC6, 0x45, 0xED, 0x65, 0xC6, 0x45, 0xEE, 0x74, 0xC6,
		0x45, 0xEF, 0x00, 0xC6, 0x45, 0xB8, 0x43, 0xC6, 0x45, 0xB9, 0x72, 0xC6, 0x45, 0xBA, 0x65, 0xC6,
		0x45, 0xBB, 0x61, 0xC6, 0x45, 0xBC, 0x74, 0xC6, 0x45, 0xBD, 0x65, 0xC6, 0x45, 0xBE, 0x44, 0xC6,
		0x45, 0xBF, 0x65, 0xC6, 0x45, 0xC0, 0x63, 0xC6, 0x45, 0xC1, 0x6F, 0xC6, 0x45, 0xC2, 0x6D, 0xC6,
		0x45, 0xC3, 0x70, 0xC6, 0x45, 0xC4, 0x72, 0xC6, 0x45, 0xC5, 0x65, 0xC6, 0x45, 0xC6, 0x73, 0xC6,
		0x45, 0xC7, 0x73, 0xC6, 0x45, 0xC8, 0x6F, 0xC6, 0x45, 0xC9, 0x72, 0xC6, 0x45, 0xCA, 0x00, 0xC6,
		0x45, 0xDC, 0x44, 0xC6, 0x45, 0xDD, 0x65, 0xC6, 0x45, 0xDE, 0x63, 0xC6, 0x45, 0xDF, 0x6F, 0xC6,
		0x45, 0xE0, 0x6D, 0xC6, 0x45, 0xE1, 0x70, 0xC6, 0x45, 0xE2, 0x72, 0xC6, 0x45, 0xE3, 0x65, 0xC6,
		0x45, 0xE4, 0x73, 0xC6, 0x45, 0xE5, 0x73, 0xC6, 0x45, 0xE6, 0x00, 0x8D, 0x45, 0xE8, 0x50, 0xFF,
		0x55, 0x98, 0x89, 0x45, 0xA8, 0x8D, 0x55, 0xB8, 0x8B, 0x4D, 0xA8, 0xE8, 0xE0, 0x01, 0x00, 0x00,
		0x89, 0x45, 0x88, 0x8D, 0x55, 0xDC, 0x8B, 0x4D, 0xA8, 0xE8, 0xD2, 0x01, 0x00, 0x00, 0x89, 0x85,
		0x7C, 0xFF, 0xFF, 0xFF, 0xE8, 0x97, 0x01, 0x00, 0x00, 0x89, 0x45, 0xF8, 0x8B, 0x4D, 0xF8, 0x89,
		0x4D, 0x94, 0x8B, 0x55, 0x94, 0x8B, 0x45, 0xF8, 0x03, 0x42, 0x3C, 0x89, 0x45, 0xAC, 0x8B, 0x4D,
		0xAC, 0x0F, 0xB7, 0x51, 0x14, 0x8B, 0x45, 0xAC, 0x8D, 0x4C, 0x10, 0x18, 0x89, 0x4D, 0x90, 0xBA,
		0x28, 0x00, 0x00, 0x00, 0xC1, 0xE2, 0x00, 0x8B, 0x45, 0x90, 0x8B, 0x4C, 0x10, 0x0C, 0x03, 0x4D,
		0xF8, 0x89, 0x4D, 0xF4, 0xC7, 0x45, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xF4, 0x89, 0x55,
		0xB4, 0xC7, 0x45, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF4, 0x83, 0xC0, 0x04, 0x89, 0x45,
		0x8C, 0x8B, 0x4D, 0xB4, 0x8B, 0x55, 0xF4, 0x03, 0x11, 0x89, 0x55, 0xFC, 0x8B, 0x45, 0xFC, 0x8B,
		0x48, 0x10, 0x89, 0x4D, 0x84, 0x8B, 0x55, 0xFC, 0x8B, 0x42, 0x0C, 0x03, 0x45, 0xF8, 0x89, 0x85,
		0x6C, 0xFF, 0xFF, 0xFF, 0xC7, 0x45, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x4D, 0xA0, 0x51, 0x6A,
		0x00, 0x6A, 0x04, 0xFF, 0x55, 0x88, 0x89, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x8B, 0x55, 0xB4, 0x8B,
		0x45, 0xF4, 0x03, 0x02, 0x89, 0x45, 0xF0, 0xC7, 0x45, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45,
		0xFC, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xB0, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x09, 0x8B, 0x4D,
		0xB0, 0x83, 0xC1, 0x01, 0x89, 0x4D, 0xB0, 0x8B, 0x55, 0xB0, 0x3B, 0x55, 0x84, 0x7D, 0x57, 0x8B,
		0x45, 0xF0, 0x89, 0x45, 0xFC, 0x8B, 0x4D, 0xF0, 0x83, 0xC1, 0x14, 0x89, 0x4D, 0xA4, 0xC7, 0x45,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x55, 0x80, 0x52, 0x8B, 0x45, 0xFC, 0x8B, 0x08, 0x51, 0x8B,
		0x55, 0xFC, 0x8B, 0x42, 0x04, 0x03, 0x45, 0xF8, 0x50, 0x8B, 0x4D, 0xFC, 0x8B, 0x51, 0x08, 0x52,
		0x8B, 0x45, 0xA4, 0x50, 0x8B, 0x4D, 0xA0, 0x51, 0xFF, 0x95, 0x7C, 0xFF, 0xFF, 0xFF, 0x89, 0x85,
		0x78, 0xFF, 0xFF, 0xFF, 0x8B, 0x55, 0xFC, 0x8B, 0x42, 0x08, 0x8B, 0x4D, 0xF0, 0x8D, 0x54, 0x01,
		0x14, 0x89, 0x55, 0xF0, 0xEB, 0x98, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xC1, 0xE0, 0x00, 0x8B, 0x4D,
		0xAC, 0x8D, 0x54, 0x01, 0x78, 0x89, 0x95, 0x74, 0xFF, 0xFF, 0xFF, 0x8B, 0x85, 0x74, 0xFF, 0xFF,
		0xFF, 0x8B, 0x08, 0x03, 0x4D, 0xF8, 0x89, 0x8D, 0x70, 0xFF, 0xFF, 0xFF, 0x8B, 0x95, 0x70, 0xFF,
		0xFF, 0xFF, 0x8B, 0x4D, 0xF8, 0xE8, 0x86, 0x01, 0x00, 0x00, 0xFF, 0xA5, 0x6C, 0xFF, 0xFF, 0xFF,
		0x33, 0xC0, 0x8B, 0xE5, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x55, 0x8B, 0xEC, 0x51, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x64, 0xA1, 0x18, 0x00, 0x00,
		0x00, 0x8B, 0x40, 0x30, 0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x0C, 0x8B, 0x00, 0x8B, 0x00, 0x8B, 0x40,
		0x18, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0xFC, 0x8B, 0xE5, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x55, 0x8B, 0xEC, 0x51, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x64, 0xA1, 0x18, 0x00, 0x00,
		0x00, 0x8B, 0x40, 0x30, 0x8B, 0x40, 0x08, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0xFC, 0x8B, 0xE5, 0x5D,
		0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x18, 0x53, 0x56, 0x57, 0x8B, 0xF9, 0x8B, 0xDA, 0x33, 0xF6, 0x89,
		0x5D, 0xEC, 0x89, 0x7D, 0xF4, 0x8B, 0x47, 0x3C, 0x8B, 0x54, 0x38, 0x78, 0x03, 0xD7, 0x89, 0x55,
		0xE8, 0x81, 0xFB, 0xFF, 0xFF, 0x00, 0x00, 0x77, 0x29, 0x0F, 0xB7, 0xCB, 0x2B, 0x4A, 0x10, 0x8D,
		0x41, 0x01, 0x3B, 0x42, 0x14, 0x76, 0x09, 0x5F, 0x5E, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3,
		0x8B, 0x42, 0x1C, 0x8D, 0x04, 0x88, 0x8B, 0x04, 0x38, 0x03, 0xC7, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5,
		0x5D, 0xC3, 0x33, 0xC9, 0x8B, 0xC3, 0x89, 0x4D, 0xFC, 0x38, 0x0B, 0x74, 0x0F, 0x0F, 0x1F, 0x00,
		0x8D, 0x40, 0x01, 0x41, 0x80, 0x38, 0x00, 0x75, 0xF7, 0x89, 0x4D, 0xFC, 0x8B, 0x42, 0x18, 0x33,
		0xDB, 0x89, 0x45, 0xF0, 0x85, 0xC0, 0x74, 0x58, 0x8B, 0x52, 0x20, 0x03, 0xD7, 0x89, 0x55, 0xF8,
		0x8B, 0x32, 0x33, 0xC0, 0x03, 0xF7, 0x38, 0x06, 0x74, 0x0D, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
		0x40, 0x80, 0x3C, 0x30, 0x00, 0x75, 0xF9, 0x3B, 0xC8, 0x75, 0x25, 0x33, 0xFF, 0x85, 0xC0, 0x74,
		0x18, 0x8B, 0x55, 0xEC, 0x2B, 0xF2, 0x8A, 0x0A, 0x3A, 0x0C, 0x16, 0x75, 0x06, 0x47, 0x42, 0x3B,
		0xF8, 0x72, 0xF3, 0x8B, 0x4D, 0xFC, 0x8B, 0x55, 0xF8, 0x3B, 0xF8, 0x74, 0x23, 0x8B, 0x7D, 0xF4,
		0x8B, 0x45, 0xF0, 0x43, 0x83, 0xC2, 0x04, 0x89, 0x55, 0xF8, 0x3B, 0xD8, 0x72, 0xB2, 0x33, 0xF6,
		0x33, 0xC9, 0x3B, 0xD8, 0x5F, 0x0F, 0x44, 0xF1, 0x8B, 0xC6, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3,
		0x8B, 0x75, 0xE8, 0x8B, 0x55, 0xF4, 0x5F, 0x8B, 0x46, 0x24, 0x8D, 0x04, 0x58, 0x0F, 0xB7, 0x0C,
		0x10, 0x8B, 0x46, 0x1C, 0x8D, 0x04, 0x88, 0x33, 0xC9, 0x8B, 0x34, 0x10, 0x8B, 0x45, 0xF0, 0x03,
		0xF2, 0x3B, 0xD8, 0x0F, 0x44, 0xF1, 0x8B, 0xC6, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0xCC, 0xCC,
		0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x34, 0x53, 0x56, 0x8B, 0xDA, 0x89, 0x4D, 0xF4, 0x57, 0x89, 0x5D,
		0xFC, 0xC7, 0x45, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x64, 0xA1, 0x18, 0x00, 0x00, 0x00, 0x8B, 0x40,
		0x30, 0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x0C, 0x8B, 0x00, 0x8B, 0x00, 0x8B, 0x40, 0x18, 0x89, 0x45,
		0xF8, 0x8B, 0x4D, 0xF8, 0x8D, 0x55, 0xE0, 0xC7, 0x45, 0xE0, 0x4C, 0x6F, 0x61, 0x64, 0xC7, 0x45,
		0xE4, 0x4C, 0x69, 0x62, 0x72, 0xC7, 0x45, 0xE8, 0x61, 0x72, 0x79, 0x41, 0xC6, 0x45, 0xEC, 0x00,
		0xE8, 0x9B, 0xFE, 0xFF, 0xFF, 0x0F, 0x57, 0xC0, 0x89, 0x45, 0xF8, 0xC7, 0x45, 0xCC, 0x00, 0x00,
		0x00, 0x00, 0x0F, 0x11, 0x45, 0xD0, 0x8B, 0xD3, 0x8D, 0x4D, 0xCC, 0xBE, 0x13, 0x00, 0x00, 0x00,
		0x8A, 0x01, 0x3A, 0x02, 0x75, 0x07, 0x41, 0x42, 0x83, 0xEE, 0x01, 0x75, 0xF3, 0x0F, 0xB6, 0x09,
		0x0F, 0xB6, 0x02, 0x2B, 0xC8, 0x74, 0x67, 0x8B, 0x43, 0x10, 0x8B, 0x4D, 0xF4, 0x83, 0x3C, 0x08,
		0x00, 0x8D, 0x3C, 0x08, 0x75, 0x08, 0x83, 0xC3, 0x14, 0x89, 0x5D, 0xFC, 0xEB, 0xC8, 0x8B, 0x33,
		0x85, 0xF6, 0x0F, 0x44, 0xF0, 0x8B, 0x43, 0x0C, 0x03, 0xC1, 0x03, 0xF1, 0x50, 0xFF, 0x55, 0xF8,
		0x8B, 0x0E, 0x89, 0x45, 0xF0, 0x85, 0xC9, 0x74, 0x2A, 0x8B, 0x5D, 0xF4, 0x79, 0x05, 0x0F, 0xB7,
		0xD1, 0xEB, 0x05, 0x8D, 0x53, 0x02, 0x03, 0xD1, 0x8B, 0xC8, 0xE8, 0x21, 0xFE, 0xFF, 0xFF, 0x83,
		0xC6, 0x04, 0x89, 0x07, 0x8B, 0x45, 0xF0, 0x83, 0xC7, 0x04, 0x8B, 0x0E, 0x85, 0xC9, 0x75, 0xDC,
		0x8B, 0x5D, 0xFC, 0x83, 0xC3, 0x14, 0x89, 0x5D, 0xFC, 0xE9, 0x78, 0xFF, 0xFF, 0xFF, 0x5F, 0x5E,
		0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x00
	};
	m_nDecompressCodeSize = 1256;
	m_nDecompressCodeSize = m_nDecompressCodeSize + 4;
	m_pDecompressCodeBuff = new char[m_nDecompressCodeSize];

	memcpy(m_pDecompressCodeBuff, &m_nDecompressCodeSize, sizeof(m_nDecompressCodeSize));
	memcpy(m_pDecompressCodeBuff + sizeof(m_nDecompressCodeSize), data, sizeof(data));
	return true;
}

bool CMyMake::GetDeCodeAndDataSec()
{
	/*char* m_pDeCodeAndDataSec = nullptr;
	int m_nsizeOfDeCodeAndDataSec = 0;*/


	/*
	-------------
	| 解压缩代码 |
	| 大小       |
	-------------
	| 解压缩代码 |
	-------------
	|  压缩个数 |
	-------------
	| 解压缩地址|
	| 压缩大小   |
	-------------
	| 解压缩地址 |
	| 压缩大小   |
	-------------
	| ...       |
	| ...       |
	-------------
	*/

	// 

	//放在压缩数据节头的信息
	struct DataInfo
	{
		int m_nVirtualSize; //解压缩后数据的大小
		int m_nVirtualAddress; //解压缩后数据的地址
		int m_nCompressSize; //压缩数据的大小
		int m_nEntryPoint;//OEP
		int m_nSectionNum;
	};
	//申请解压缩代码和压缩数据空间大小
	int nSectionNum = m_pNtHdr->FileHeader.NumberOfSections;
	int nSectionSumOfSize = 0;
	DataInfo* pData=NULL;
	pData = new DataInfo[nSectionNum];
	for(int i=0;i<nSectionNum;i++)
	{
		nSectionSumOfSize = nSectionSumOfSize + m_pCompressDatas[i].m_nComSize;
		pData[i].m_nCompressSize = m_pCompressDatas[i].m_nComSize;
		pData[i].m_nVirtualSize = m_pCompressDatas[i].m_nSrcSize;
		pData[i].m_nVirtualAddress = m_pSecHdrs[i].VirtualAddress;
		pData[i].m_nEntryPoint = m_pNtHdr->OptionalHeader.AddressOfEntryPoint;
		pData[i].m_nSectionNum = nSectionNum;
	}
	nSectionSumOfSize = nSectionSumOfSize + sizeof(DataInfo)*nSectionNum+sizeof(nSectionNum);
	
	int nAllocSize = m_nDecompressCodeSize + nSectionSumOfSize + sizeof(m_nDecompressCodeSize);

	nAllocSize=GetAlinValue(nAllocSize, m_pNtHdr->OptionalHeader.FileAlignment);

	m_nsizeOfDeCodeAndDataSec = nAllocSize;

	 m_pDeCodeAndDataSec = new char[nAllocSize];

	DWORD nOffset = (DWORD)m_pDeCodeAndDataSec;
	//往空间里面拷贝数据

	//1.拷贝解压缩代码
		//拷贝代码大小
	//memcpy((LPVOID)nOffset, (char*)&m_nDecompressCodeSize, sizeof(m_nDecompressCodeSize));
	//nOffset = nOffset + sizeof(m_nDecompressCodeSize);
	//拷贝解压缩代码
	memcpy((LPVOID)nOffset, m_pDecompressCodeBuff, m_nDecompressCodeSize);
	nOffset = nOffset + m_nDecompressCodeSize;

	//2.拷贝压缩节

	//拷贝节个数
	/*memcpy((LPVOID)nOffset, (char*)&nSectionNum,sizeof(nSectionNum));
	nOffset = nOffset + sizeof(nSectionNum);*/
	//
	for(int i=0;i<nSectionNum;i++)
	{
		//拷贝压缩节描述信息
		memcpy((LPVOID)nOffset, (char*)&pData[i], sizeof(DataInfo));
		nOffset = nOffset + sizeof(DataInfo);
		memcpy((LPVOID)nOffset, m_pCompressDatas[i].m_pComData, m_pCompressDatas[i].m_nComSize);
		nOffset = nOffset + m_pCompressDatas[i].m_nComSize;
	}

	return true;
}


bool CMyMake::GetNewSectionHeaders()
{
	m_pNewSecHdrs = new IMAGE_SECTION_HEADER[2];
	enum
	{
		SECIDX_SPACE,
		SECIDX_CODE_DATA
	};

	//构建空节
	strcpy((char*)m_pNewSecHdrs[SECIDX_SPACE].Name, ".dec");
	m_pNewSecHdrs[SECIDX_SPACE].Misc.VirtualSize = m_pNtHdr->OptionalHeader.SizeOfImage;
	m_pNewSecHdrs[SECIDX_SPACE].VirtualAddress = m_pSecHdrs[0].VirtualAddress; //内存偏移
	m_pNewSecHdrs[SECIDX_SPACE].PointerToRawData =0; //文件偏移
	m_pNewSecHdrs[SECIDX_SPACE].SizeOfRawData = 0;//文件大小
	m_pNewSecHdrs[SECIDX_SPACE].Characteristics = IMAGE_SCN_MEM_SHARED
		                                          | IMAGE_SCN_MEM_EXECUTE
		                                          | IMAGE_SCN_MEM_READ
		                                          | IMAGE_SCN_MEM_WRITE;

	//构建数据和代码节
	strcpy((char*)m_pNewSecHdrs[SECIDX_CODE_DATA].Name, ".upx");

	m_pNewSecHdrs[SECIDX_CODE_DATA].Misc.VirtualSize = m_nsizeOfDeCodeAndDataSec;
	m_pNewSecHdrs[SECIDX_CODE_DATA].VirtualAddress = 
	m_pNewSecHdrs[SECIDX_SPACE].VirtualAddress
		+ GetAlinValue(m_pNewSecHdrs[SECIDX_SPACE].Misc.VirtualSize, m_pNtHdr->OptionalHeader.SectionAlignment);//内存偏移
	m_pNewSecHdrs[SECIDX_CODE_DATA].PointerToRawData = m_pNtHdr->OptionalHeader.SizeOfHeaders; //文件偏移
	m_pNewSecHdrs[SECIDX_CODE_DATA].SizeOfRawData = m_nsizeOfDeCodeAndDataSec;//文件大小
	m_pNewSecHdrs[SECIDX_CODE_DATA].Characteristics = IMAGE_SCN_MEM_SHARED
		| IMAGE_SCN_MEM_EXECUTE
		| IMAGE_SCN_MEM_READ
		| IMAGE_SCN_MEM_WRITE;

	return true;
}

bool CMyMake::GetNewPeHdr()
{
	//申请新PE头内存
	m_nSizeOfNewPeHdr = m_pNtHdr->OptionalHeader.SizeOfHeaders;
	m_pNewPeHdr = new char[m_nSizeOfNewPeHdr];

	//拷贝原来的PE头
	memcpy(m_pNewPeHdr, m_pDosHdr, m_nSizeOfNewPeHdr);

	//修改字段
	PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)m_pNewPeHdr;
	PIMAGE_NT_HEADERS pNtHdr = (PIMAGE_NT_HEADERS)((char*)m_pNewPeHdr + pDosHdr->e_lfanew);
	PIMAGE_SECTION_HEADER pSecHdrs = (PIMAGE_SECTION_HEADER)
		((char*)&pNtHdr->OptionalHeader + pNtHdr->FileHeader.SizeOfOptionalHeader);

	pNtHdr->FileHeader.NumberOfSections = 2;
	pNtHdr->OptionalHeader.AddressOfEntryPoint = m_pNewSecHdrs[1].VirtualAddress+4;
	pNtHdr->OptionalHeader.SizeOfImage = m_pNewSecHdrs[1].VirtualAddress
		+ GetAlinValue(m_pNewSecHdrs[1].Misc.VirtualSize, pNtHdr->OptionalHeader.SectionAlignment);

	//拷贝新构造的节表
	memcpy(
		pSecHdrs,
		m_pNewSecHdrs,
		pNtHdr->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

	return true;
}

bool CMyMake::WriteNewPeFile(std::string strDstPath)
{
	HANDLE hFle = CreateFileA(strDstPath.c_str(),
		FILE_GENERIC_READ | FILE_GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (hFle == (HANDLE)-1)
	{
		return false;
	}

	WriteFile(hFle, m_pNewPeHdr, m_nSizeOfNewPeHdr, NULL, NULL);
	WriteFile(hFle, m_pDeCodeAndDataSec, m_nsizeOfDeCodeAndDataSec, NULL, NULL);
	CloseHandle(hFle);

	return true;
}

int CMyMake::GetAlinValue(int nValue, int nAlign)
{
	if (nValue % nAlign == 0)
	{
		return nValue;
	}
	else
	{
		return (nValue / nAlign + 1) * nAlign;
	}
}

